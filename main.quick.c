#include <stdint.h>
#include <time.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;


#define ROL_16(x,n) ( ((x) << (n)) | ((x) >> (16-(n))) )
#define ROR_16(x,n) ( ((x) >> (n)) | ((x) << (16-(n))) )


/* bit count is: 31, generated by cformatu.sh */
static const u8 z[31]={1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0};

#define SIMON_M 4
#define SIMON_T 32

void simon3264_keyexpansion(u16 *k)
{
    u16 tmp,tmp2;
    u32 i;
    
/*
The cipher
./bin/simontool.elf -e -b 32 -k 64 -s 0000000000000000 -t 00000000 -l e.txt, and looking in e.txt
You can verify this by setting k[0,1,2,3] to zero.

*/    
    
    for ( i=SIMON_M ; i<SIMON_T ; i++ )
    {
        tmp = ROR_16(k[i-1],3);
     //   fprintf(stdout,"\n       %04x = ROR(%04x,3);      (tmp = ROR_16(k[i-1],3))\n",tmp,k[i-1]);
        tmp2 = tmp ^ k[i-3];
     //   fprintf(stdout,"       %04x = %04x ^ %04x;  (tmp2 = tmp ^ k[i-3])\n",tmp2,tmp,k[i-3]);
        tmp = tmp2 ^ ROR_16(tmp2,1);
     //   fprintf(stdout,"       %04x = %04x ^ %04x;  (tmp = tmp2 ^ ROR_16(tmp2,1))\n",tmp,tmp2, ROR_16(tmp2,1));

        k[i] = ~k[i-4] ^ tmp ^ z[i-4] ^ 3;
      //  fprintf(stdout,"k[%02i]: %04x = %04x ^ %04x ^ %02x ^ %02x\n",i,k[i],~k[i-4],tmp,z[i-4],3);
    }

}

u32 simon3264_encryption(u16 *key, u32 cword)
{
	u32 i;
	u16 crypt[2];
	u16 tmp;
	crypt[0]= cword >>16;
	crypt[1]= cword;
	
//	printf("words: 0x%04x 0x%04x\n",crypt[0],crypt[1]);
	for ( i=0 ; i<SIMON_T ; i++ )
    {
        tmp = crypt[0];
        crypt[0] = crypt[1] ^ ((ROL_16(crypt[0],1)) & (ROL_16(crypt[0],8))) ^ (ROL_16(crypt[0],2)) ^ key[i];
        crypt[1] = tmp;
//       printf("k[%02i]  %04x \n",i,key[i]);
//       printf("c[%02i]  %04x %04x\n",i,crypt[0],crypt[1]);
    }
    //printf("crypt: 0x%04x 0x%04x\n",crypt[0],crypt[1]);

	i = 0;
	i = (crypt[0] << 16) | crypt[1];
	return(i);
}

/*
**  void datafile_increment(FILE *fp, u32 inclocation)
**  increments the byte in a file at some location
*/
void datafile_increment(FILE *fp, u32 inclocation)
{
	u8 l_singlebyte;
	fseek(fp,inclocation,SEEK_SET);  //skip to the offset
	fread(&l_singlebyte, 1, 1, fp);
	l_singlebyte++;  //increment
	fseek(fp,inclocation,SEEK_SET);
	fwrite(&l_singlebyte, 1, 1, fp);

}

int main (int argc, char **argv) {

	u32 l_counter32=0;
	u32 l_progress=0;
	u32 l_result=0;
	u8  l_ubyte=0;
	u8  l_singlebyte;
	u64 time_start, time_tick, time_elapsed;  //time
	u16 a_keyexpansion[SIMON_T];  //There are 32 rounds in Simon 32/64, and 4 keys at 16 bits 
	u32 a_zerospectrum[SIMON_T];
	
	//get our initial time
	time_start= clock();
	//check to see if we can write the files.
	//key verification	
/*
	a_keyexpansion[0]=0x0100;
	a_keyexpansion[1]=0x0908;
	a_keyexpansion[2]=0x1110;
	a_keyexpansion[3]=0x1918;
	l_result=0x65656877;
*/
	srand((unsigned int)time(NULL));
	a_keyexpansion[0]=(u16)rand();
	a_keyexpansion[1]=(u16)rand();
	a_keyexpansion[2]=(u16)rand();
	a_keyexpansion[3]=(u16)rand();
	//write out the key to the file
	fprintf(stdout,"key:\n%04x %04x %04x %04x\n",a_keyexpansion[3],a_keyexpansion[2],a_keyexpansion[1],a_keyexpansion[0]);
	simon3264_keyexpansion(a_keyexpansion);



	l_progress=0xFFFFFFFF;
	//now look at the 32-bit data space for the given key
	for(l_counter32=0;l_counter32<l_progress;l_counter32++)
	{
	   l_result=simon3264_encryption(a_keyexpansion,l_counter32);
	}
	l_result=simon3264_encryption(a_keyexpansion,l_counter32);
	time_tick= clock();
    time_elapsed = (time_tick - time_start) / CLOCKS_PER_SEC;
    fprintf(stdout,"data counter: 0x%08x\n",l_progress);
	fprintf(stdout,"data complete,elapsed sec: %llu\n",time_elapsed);
	//zero the data array


	return(0);
}
